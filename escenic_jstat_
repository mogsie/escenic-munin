#!/bin/bash

: <<=cut
=head1 NAME

escenic_jstat_ - Munin plugin that interacts with the jstat tool, to show
(among other things), the heap usage of instances of Escenic Content Engine

=head1 APPLICABLE SYSTEMS

escenic_jstat_ works with all installations of Escenic Content Engine 5.1
and onwards.  It uses the pidfiles located in /var/run/escenic/ to locate
different instances of Content Engine and graphs their heaps individually.

=head1 CONFIGURATION

escenic_jstat_ needs to know which instance it will run on.  Since 5.1,
ECE out of the box allows easy configuration of several instances.  These
end up putting their pidfiles in /var/run/escenic/ece-xxx.pid.  This munin
plug-in suggests a set of graphs for each of the currently running instances.

The plugin uses the jstat utility from the JVM which it assumes is available
in the path.  jstat itself must execute as the same user that owns the
process being monitored, which means that the plugin itself must be run as
that user.

   [escenic_jstat_default_*]
         user escenic
   [escenic_jstat_test_*]
         user test

=head1 INTERPRETATION

The system suggests three graphs.  The "heap" graph tries to visualize the
entire heap in three distinct areas:

The bottom area (green) indicates the size of the young generation, which
consists of "eden", "survivor0" and "survivor1".  Stacked on top of that
is the unused portion of that heap (in a light gray tint).

The middle area (red) indicates the size of the old generation, which
consists of objects that survived being in the young generation for a while.
Stacked on top of that is again the unused portion of the old generation.

The top area (blue) indicates the size of the permanent generation, which
consists of classes and other things.

The -Xmx parameter controls the size of the young and the old generation, so
the top of the free space of the old generation should correspond exactly
with the value of -XMx.  The capacity of the permanent generation is usually
controlled via the proprietary -XX:MaxPermSize parameter.

The second graph is a garbage collection graph which shows the progress of
the garbage collector, namely the number of garbage collections per minute.

=head1 MAGIC MARKERS

    #%# family=auto contrib
    #%# capabilities=autoconf suggest

=head1 CONFIGURATION

There are a few options that can be specified to control how a particular
instance of this works, if you run a non-standard setup, e.g. pidfiles in
other locations, etc.

    jstatbin     - path to jstat executable. Defaults to
                   '/etc/alternatives/jstat'

    ece_instance - name of instance. Defaults to output of 'suggest'
                   The instance names is used to group and title graphs,
                   and to locate the pidfile

    pidfile      - Override name of pidfile to use. Defaults to
                   '/var/run/escenic/ece-${ece_instance}.pid'

    graphtitle   - if unspecified, the graph title is appended with the
                   name of the instance.

=cut


# suggest suggests escenic_jstat_<instancename>_xxx
graph_update=yes
jstatbin=${jstatbin:-$(which jstat)}
ece_instance=$(echo $(basename $0) | sed -e s,escenic_jstat_,, -e 's,_.*,,' )
graph=$(echo $(basename $0) | sed s,escenic_jstat_${ece_instance}_,,)

MUNIN_VERSION=${MUNIN_VERSION:-1.2.5}
MAJOR_VERSION=${MUNIN_VERSION/.*/}
MINOR_VERSION=${MUNIN_VERSION/${MAJOR_VERSION}./}
MINOR_VERSION=${MINOR_VERSION/.*/}
MAINT_VERSION=${MUNIN_VERSION/${MAJOR_VERSION}.${MINOR_VERSION}./}

borrowed_labels=0
if [ "${MAJOR_VERSION}" -gt 1 ] ; then
  borrowed_labels=1
elif [ "${MAJOR_VERSION}" -eq 1 ] ; then
  if [ "${MINOR_VERSION}" -gt 3 ] ; then
    borrowed_labels=1
  fi
fi
  

tmp_pidfile="/var/run/escenic/ece-${ece_instance}.pid"
pidfile=${pidfile:-${tmp_pidfile}}

if [ ! -r "$jstatbin" ] ; then
  graph_info="$graph_info NOTE: jstat ($jstatbin) is not executable, so I can't output a graph."
  graph_update=no
fi

if [ ! -r "$pidfile" ] ; then
  graph_info="$graph_info NOTE: pidfile $pidfile is not readable, so I can't output a graph."
  graph_update=no
fi

if [ -r "${pidfile}" ] ; then
  owner_uid="$[$(ps -o uid= $(cat ${pidfile}))]"
  my_id="$[$(id -u)]"

  if [ "$my_id" == "0" -o "$owner_uid" != "$my_id" ] ; then
    graph_info="$graph_info NOTE: pid is owned by a different user ${owner_uid} than me ${my_id}.  So I can't run jstat to talk to it."
    graph_update=no
  fi
fi

if [ -z "${graphtitle}" ]; then
  graphtitle="${ece_instance}"
fi

config_uptime()
{
  echo "graph_title $graphtitle uptime"
  echo "graph_args --base 1000 -l 0"
  echo "graph_scale no" # In case > 1000 days :-) you never know!
  echo "graph_vlabel uptime in days"
  echo "graph_info Uptime as reported by jstat. " ${graph_info}
  echo "graph_category Escenic"
  echo "update no"  # this graph only loans from the heap graph...
  echo "graph_order uptime=escenic_jstat_${ece_instance}_heap.Uptime"

  if [ "${borrowed_labels}" == "1" ] ; then
    echo "uptime.label Uptime"
  fi
  echo "uptime.draw AREA"
  echo "uptime.info Uptime of the java process in days"
}

config_gc()
{
  echo "graph_title $graphtitle memory: Garbage collection frequency"
  echo "graph_args -l 0"
  echo "graph_scale no" # Use 0.001 or 1200.
  echo "graph_period minute"
  echo "graph_vlabel collections / \${graph_period}"
  echo "graph_info The number of garbage collections per \${graph_period}. " ${graph_info}
  echo "graph_category Escenic"
  echo "update no"  # this graph only loans from the heap graph...
  echo "graph_order young=escenic_jstat_${ece_instance}_heap.Young_Count full=escenic_jstat_${ece_instance}_heap.Full_Count"

# Labels on borrowed things are bad for munin < 1.3
  if [ "${borrowed_labels}" == "1" ] ; then
    echo "young.label Young collections"
  fi
  echo "young.draw LINE2"
  echo "young.type DERIVE"
  echo "young.min 0"
  echo "young.info The rate of young collections.  Young collections collect the eden and usually execute extremely quickly. Young collections happen asynchronously and don't adversely affect the performance of the JVM."

  if [ "${borrowed_labels}" == "1" ] ; then
    echo "full.label Full GC collections"
  fi
  echo "full.draw LINE1"
  echo "full.type DERIVE"
  echo "full.min 0"
  echo "full.info The rate of full collections.  Full collections pause all the threads of the JVM while collection is going on, which may lead to spikes in latency. The JVM tries to avoid this, since a full collection usually takes a lot longer than young collections."
}

config_gcoverhead()
{
  echo "graph_title $graphtitle memory: CPU spent by garbage collector"
  echo "graph_args --base 1000 --lower-limit 0" # --upper-limit 1000000"
  echo "graph_scale yes" # Use 0.001 or 1200.
  echo "graph_printf %6.3lf" # show more decimals.
  echo "graph_vlabel CPU time (%)"
  echo "graph_info The amount of time spent in garbage collection.  The measurement is in percent, A value of 1 means that one percent of the time is spent garbage collecting.  Low is good." ${graph_info}
  echo "graph_category Escenic"
  echo "update no"  # this graph only loans from the heap graph...
  echo "graph_order young=escenic_jstat_${ece_instance}_heap.Young_Time_millis full=escenic_jstat_${ece_instance}_heap.Full_Time_millis"

# I decided to merge the "gc time" graph data sets, since it clutters the display quite a lot.
#  echo "young.label Young_Time_millis"
#  echo "young.draw AREA"
  echo "young.type DERIVE"
  echo "young.graph no"
#  echo "young.min 0"
#  echo "young.cdef young,300000,/,100,*"
#  echo "young.info time spent (in parts per million) doing young generation garbage collection.  These collections are done incrementally and asynchronously.  The only overhead is raw CPU usage."

  if [ "${borrowed_labels}" == "1" ] ; then
    echo "full.label % time spent in GC"
  fi
  echo "full.draw LINE1"
  echo "full.type DERIVE"
  echo "full.min 0"
  echo "full.cdef young,full,+,300000,/,100,*" # 1000 (millis) * 60 (minute) * 5 (munin graph period) = 300000 ms per 5minute period.
  echo "full.info Percent of time a CPU spent doing incremental or full garbage collection."
}

config_heap()
{
  echo "graph_title $graphtitle memory: Memory usage by generation"
  echo "graph_args --base 1024 -l 0"
  echo "graph_vlabel bytes"
  echo "graph_period minute" # this propagates to where the values are used (I hope)
  echo "graph_info Heap Usage split by different blocks of heap." ${graph_info}
  echo "graph_category Escenic"
  echo "update ${graph_update}"
  echo "graph_order Eden_Used Survivor0_Used Survivor1_Used Young_Limit Young_Used Young_Free Old_Used Old_Limit Old_Free Permanent_Used Permanent_Limit Permanent_Free"

  echo "Eden_Used.label Eden"
  echo "Eden_Used.graph no"
#  echo "Eden_Used.draw AREA"
#  echo "Eden_Used.info New objects are almost always allocated here. It is a large part of the heap (typically one third) and when it is full, it is garbage collected and survivors are moved up to the Survivor portion of the young heap."
#  echo "Eden_Used.colour 00cd00" # green3

  echo "Survivor0_Used.label Survivor0_Used"
  echo "Survivor0_Used.graph no"

  echo "Survivor1_Used.label Survivor1_Used"
  echo "Survivor1_Used.graph no"

  echo "Young_Limit.label Young_Limit"
  echo "Young_Limit.graph no"  # Don't show the "limit" as-is, since it's not useful.

  echo "Young_Used.label Young used"
  echo "Young_Used.draw AREA"  # Should equate Young_limit always.
  echo "Young_Used.colour 00CD00"
  echo "Young_Used.info Objects are allocated in the young part of the heap.  The young part consists of Eden and Survivor0 and Survivor1, all of which get a certain portion of the young heap.  Objects live in the young part for a short time after which they are promoted to the old part of the heap."
  echo "Young_Used.cdef Eden_Used,Survivor0_Used,Survivor1_Used,+,+"

  echo "Young_Free.label Young unused"
  echo "Young_Free.draw STACK"  # Should equate Young_limit always.
  echo "Young_Free.colour AEE8AE" # a light green
  echo "Young_Free.cdef Young_Limit,Eden_Used,Survivor0_Used,Survivor1_Used,+,+,-"

  echo "Old_Used.label Old used"
  echo "Old_Used.draw STACK"
  echo "Old_Used.colour 3B09ED" # brown1
  echo "Old_Used.info When Survivor is full, Survivor is garbage collected and survivors are placed in the Old area"

  echo "Old_Limit.label Old_Limit"
  echo "Old_Limit.graph no"

  echo "Old_Free.label Old unused"
  echo "Old_Free.draw STACK"
  echo "Old_Free.colour C5B5FF" # AliceBlue
  echo "Old_Free.cdef Old_Limit,Old_Used,-"

  echo "Permanent_Limit.label Permanent_Limit"
  echo "Permanent_Limit.graph no"

  echo "Permanent_Used.label Permanent Used"
  echo "Permanent_Used.draw STACK"
  echo "Permanent_Used.colour FF8000" # A relatively dark blue tint
  echo "Permanent_Used.info Permanent space is only used for permanent type objects, like class loaders, classes and so on."

  echo "Permanent_Free.label Permanent unused"
  echo "Permanent_Free.draw STACK"
  echo "Permanent_Free.colour F2C79B"

  echo "Permanent_Free.cdef Permanent_Limit,Permanent_Used,-"

  echo "Young_Count.label Young_Count"
  echo "Young_Count.type DERIVE"
  echo "Young_Count.draw AREA"
  echo "Young_Count.graph no"
  echo "Full_Count.label Full_Count"
  echo "Full_Count.type DERIVE"
  echo "Full_Count.draw STACK"
  echo "Full_Count.graph no"
  echo "Young_Time_millis.label Young_Time_millis"
  echo "Young_Time_millis.type DERIVE"
  echo "Young_Time_millis.graph no"
  echo "Full_Time_millis.label Full_Time_millis"
  echo "Full_Time_millis.type DERIVE"
  echo "Full_Time_millis.graph no"

  echo "Uptime.label Uptime"
  echo "Uptime.info The current uptime (in days) as reported by jstat -t"
  echo "Uptime.draw AREA"
  echo "Uptime.graph no"
}

jstat()
{
echo "# ${jstatbin} -gc ${pid} | tail -n 1 | awk"
${jstatbin} -gc -t ${pid} | tail -n 1 | awk \
'{\
    // Timestamp S0C    S1C    S0U    S1U      EC       EU        OC         OU       PC     PU    YGC     YGCT    FGC    FGCT     GCT   
    // 123456.0  512.0  512.0   0.0   160.0   5888.0   1163.4   88704.0    48433.9   80896.0 79993.8   2181    9.993  36     12.682   22.674
	UPTIME = $1; \
	S0C = $2; \
	S1C = $3; \
	S0U = $4; \
	S1U = $5; \
	EC  = $6; \
	EU  = $7; \
	OC  = $8; \
	OU  = $9; 
	PC  = $10; \
	PU  = $11; \
        YGC = $12; \
        YGCT = $13; \
        FGC = $14; \
        FGCT = $15; \
	\
	S0F = S0C - S0U; \
	S1F = S1C - S1U; \
	EF  = EC  - EU;  \
	OF  = OC  - OU;  \
	PF  = PC  - PU;  \
	\
	printf "Eden_Used.value %d\n",EU * 1024; \
	printf "Survivor0_Used.value %d\n",S0U * 1024; \
	printf "Survivor1_Used.value %d\n", S1U * 1024; \
	printf "Old_Used.value %d\n", OU * 1024; \
	printf "Permanent_Used.value %d\n", PU * 1024; \
	printf "Young_Count.value %d\n", YGC; \
	printf "Full_Count.value %d\n", FGC; \
	printf "Young_Time_millis.value %d\n", YGCT * 1000; \
	printf "Full_Time_millis.value %d\n", FGCT * 1000; \
	printf "Uptime.value %.2f\n", UPTIME/86400; \
}'

${jstatbin} -gccapacity ${pid} | tail -n 1 | awk \
'{\
 //NGCMN    NGCMX     NGC     S0C   S1C       EC      OGCMN      OGCMX       OGC         OC      PGCMN    PGCMX     PGC       PC     YGC    FGC 
 //21056.0 337216.0  41792.0 7552.0 8000.0  25792.0    42176.0   674496.0    73216.0    73216.0  21248.0  86016.0  75392.0  75392.0     72     3
        NGCMX = $2; \
        OGCMX = $8; \
        PGCMX = $12; \
	printf "Young_Limit.value %d\n", NGCMX * 1024; \
	printf "Old_Limit.value %d\n", OGCMX * 1024; \
	printf "Permanent_Limit.value %d\n", PGCMX * 1024; \
}'

}

#
# autoconf
#

if [ "$1" = "autoconf" ]; then

  if [ ! -x "${jstatbin}" ]; then
    echo "no (No jstat found)"
    exit 0
  fi

  if [ "$(ls 2>/dev/null /var/run/escenic/ece-*.pid | wc -l)" == "0" ]; then
    echo "no (No escenic pidfiles in /var/run/escenic/ece-*.pid)"
    exit 0
  fi

  echo "yes"
  exit 0
fi


#
# suggest
#

if [ "$1" = "suggest" ]; then

  for a in /var/run/escenic/ece-*.pid ; do
    ece_instance=$(basename $a .pid | sed s/^ece-//)
    echo ${ece_instance}_heap
    echo ${ece_instance}_gc
    echo ${ece_instance}_gcoverhead
    echo ${ece_instance}_uptime
  done

  exit 0
fi


#
# debug
#
if [ "$1" == "debug" ] ; then
  echo "# Debug information"
  env
  exit 0
fi

#
# config
#
if [ "$1" == "config" ] ; then
  config_${graph}
  exit 0
fi

#
# Main
#
pid=$(cat ${pidfile})
# echo '#' $pid

if [ "${graph}" == "heap" ] ; then
  jstat
fi



# 1.4.5 environment

# MUNIN_BASH=/bin/bash
# MUNIN_PLUGSTATE=/var/lib/munin/plugin-state
# MUNIN_PERL=/usr/bin/perl
# MUNIN_STATEDIR=/var/run/munin
# MUNIN_PYTHON=/usr/bin/env python
# MUNIN_PLUGINUSER=nobody
# MUNIN_LOGDIR=/var/log/munin
# MUNIN_PERLLIB=/usr/share/perl5
# MUNIN_HASSETR=1
# MUNIN_LIBDIR=/usr/share/munin
# MUNIN_HTMLDIR=/var/cache/munin/www
# MUNIN_CAP_MULTIGRAPH=1
# MUNIN_OSTYPE=linux
# MUNIN_BINDIR=/usr/bin
# MUNIN_GOODSH=/bin/sh
# MUNIN_SBINDIR=/usr/sbin
# MUNIN_HOSTNAME=localhost.localdomain
# MUNIN_VERSION=1.4.5
# MUNIN_MASTER_IP=
# MUNIN_DOCDIR=/usr/doc
# MUNIN_RUBY=/usr/bin/env ruby
# MUNIN_CGIDIR=/usr/lib/cgi-bin
# MUNIN_MANDIR=/usr/share/man
# MUNIN_DBDIR=/var/lib/munin
# MUNIN_CONFDIR=/etc/munin
# MUNIN_STATEFILE=/var/lib/munin/plugin-state/something
# MUNIN_USER=munin
# MUNIN_GROUP=munin
# MUNIN_PREFIX=/usr
